#ifndef GSOBJECT_H
#define GSOBJECT_H

#include <QObject>
#include <QQmlEngine>
#include <QStack>

#include "sourceparser.h"

#include <QDebug>

class GSObject;

class OwnNotifier : public QObject {
	Q_OBJECT
public:
	OwnNotifier(QString name, GSObject* parent);
public slots:
	void notify();
signals:
	void notified(QString name, QVariant value);
private:
	QString mName;
	GSObject* mParent;
};

/**
 * @brief Вспомогательный класс для привязки свойств.
 *
 * Класс предназначен для реализации привязки свойств объектов GSObject. Объект
 * PropertyListener создается на каждую привязку свойства-получателя. Объект
 * содержит полную информацию о привязке - указатели на объекты отправителя и
 * получателя и имена свойств. Слот notify() устанавливает значение
 * свойства-получателя равным значению свойства-источника. В случае, если
 * свойство-источник является статическим, его сигнал оповещения об изменении
 * подключается к слоту notify(). Если свойство-источник яляется динамическим,
 * слот notify() вызывается явно при обработке события изменения динамического
 * свойства в функции eventFilter() объекта-получателя. При изменении свойства
 * генерируется сигнал notified(). Данный сигнал генерируется вне зависимости
 * от того, изменилось ли значение свойства.
 */
class PropertyListener : public QObject {
	Q_OBJECT
public:
	/**
	 * @brief Конструктор.
	 * @param sender объект-отправитель
	 * @param source свойство-источник
	 * @param receiver объект-получатель
	 * @param destination свойство-получатель
	 */
	PropertyListener(
		GSObject* sender, QString source,
		GSObject* receiver, QString destination);

	/**
	 * @brief Признак, является ли свойство-источник динамическим.
	 * В зависимости от этого признака, при удалении привязки
	 * свойство-источник может удаляться из списка наблюдаемых свойств
	 * объекта-получателя.
	 * @return признак, является ли свойство-источник динамическим
	 */
	bool dynamic() const;
	/**
	 * @brief Задание признака динамического свойства-источника.
	 * Функция должна явно вызываться после создания объекта
	 * PropertyListener, автоматического определения "динамичности" не
	 * выполняется.
	 * @param dynamic признак, является ли свойство-источник динамическим
	 */
	void setDynamic(bool dynamic);

	/**
	 * @brief Объект-отправитель.
	 * @return указатель на объект-отправитель
	 */
	GSObject *sender() const;
	/**
	 * @brief Объект-получатель.
	 * @return указатель на объект-получатель
	 */
	GSObject *receiver() const;
	/**
	 * @brief Свойство-источник.
	 * @return имя свойства-источника
	 */
	QString source() const;
	/**
	 * @brief Свойство-получатель.
	 * @return имя свойства-получателя
	 */
	QString destination() const;

public slots:
	/**
	 * @brief Согласование привязанного свойства.
	 * Функция устанавливает значение свойства-получателя равным значению
	 * свойства-источника.
	 */
	void notify();

signals:
	/**
	 * @brief Сигнал оповещения о согласовании свойств.
	 * Сигнал генерируется при изменении свойства-получателя через функцию
	 * notify(). Данный сигнал генерируется вне зависимости от того,
	 * изменилось ли значение свойства.
	 */
	void notified();

private:
	GSObject* mSnd;
	QString mSprop;
	GSObject* mRcv;
	QString mRprop;
	bool mDynamic;
};

class GSContext;

/**
 * @brief Базовый класс объекта GS.
 *
 * Реализует всю базовую функциональность: чтение данных из секции, создание
 * дочерних объектов (при помощи GSObjectFactory), подключение сигналов/слотов
 * и привязка свойств.
 *
 * Данный класс не обязан самостоятельно реализовывать всю функциональность -
 * например, объекты GUI включены в классы, производные от GSObject, в качестве
 * агрегатов. Задача класса GSObject - обеспечить интерфейс взаимодействия
 * объектов на уровне языка Squill.
 *
 * В основе работы данного класса лежат механизмы сигналов/слотов и свойств,
 * которые предоставляет класс QObject. Центральный объект типа QObject может
 * быть получен при помощи функции object(). Этот объект используется для
 * работы с упомянутыми механизмами, при этом класс GSObject выступает как
 * мост. В реализации по умолчанию центральным объектом является сам объект
 * GSObject. Но в производных классах центральный объект может быть другой -
 * например, при реализации объекта QML центральным объектом является объект
 * QML, который может взаимодействовать с другими объектами как через интерфейс
 * QML, так и через Squill.
 *
 * Объекты составляют иерархию. Иерархия определяется в файле проекта и не
 * меняется в процессе работы.
 *
 * Объект класса работает в контексте имен. Имя видимого объекта может быть
 * использовано для подключения сигналов/слотов и привязки свойств в рамках
 * секции данного объекта. В контекст входят:
 *	* сам объект: под своим именем и специальным именем **this**;
 *	* родительский объект: под своим именем и специальным именем parent;
 *	* дочерние объекты под своими именами;
 *	* "родственные" объекты - дочерние объекты родительского объекта -
 *	под своими именами;
 *	* контекст под пустым именем и специальным именем context.
 * Объект с заданным именем может быть получен или установлен при помощи
 * соответствующих функций localObject() и setLocalObject() соответственно.
 * Список имен видимых объектов и дочерних объектов может быть получен при
 * помощи функций localObjects() и childrenObjects() соответственно.
 * Родительский объект может быть получен при помощи функции gsParent().
 *
 * Объект контекста GSContext используется в качестве хранилища глобальных
 * переменных. Этот объект может быть получен при помощи функции
 * contextObject(). Объект контекста создается при помощи функции makeContext()
 * на основе контекста родителя. Реализация по умолчанию возвращает контекст
 * родителя - таким образом, контекст дочернего класса наследуется у родителя.
 * В объектах верхнего уровня - главном окне и диалогах - функция должна
 * явно создавать новый контекст, т.к., например, для главного окна родителя не
 * будет.
 *
 * Каждых объект также может обладать собственным QML-контекстом (не путать с
 * GSContext). QML-контекст может быть получен при помощи функции qmlContext().
 * QML-контекст создается по требованию при первом вызове данной функции.
 * QML-контекст создается на основе QML-контекста родителя, а если родителя нет
 * или QML-контекст у него не задан, QML-контекст объекта создается при помощи
 * функции makeRootQmlContext(). QML-контекст включает те же имена, которые
 * доступны в контексте объекта.
 *
 * Механизм свойств основан на свойствах класса QObject, но не совпадает с ним.
 * Для доступа к свойствам используются функции gsProperty(), hasGSProperty(),
 * setGSProperty() и gsProperties(), а также сигнал gsPropertyChanged().
 * Свойства могут быть как статическими, так и динамическими, класс не делает
 * между ними различий. Например, в отличии от функции
 * QObject::dynamicPropertyNames и QMetaObject::propertyCount, работающих со
 * списками динамических и статических свойств соответственно, функция
 * gsProperties() возвращает список имен всех свойств. Свойства объекта
 * дублируются в QML-контексте, чтобы объекты QML могли иметь к ним доступ.
 * При работе со свойствами следует использовать соответствующие функции класса
 * GSObject, а не функции класса QObject, т.к. при использовании последних
 * согласованность свойств объекта и QML-контекста не может быть гарантирована.
 *
 * Дочерние объекты также представлены свойствами и могут быть получены при
 * помощи функции gsProperty(), а также через QML-контекст в объектах QML.
 *
 * Некоторые свойства имеют векторный тип даже в том случае, если хранят только
 * одно значение (например, поле запроса). Для преобразования векторного
 * значения свойства в скалярное предназначена функция gsToScalar().
 *
 * Объект создается в два этапа: работа конструктора и работы функции
 * loadSource(). Конструктор должен определить родителя и центральный объект.
 * На этапе заполнения (функция loadSource()) производятся следующие действия:
 *	* создается или наследуется контекст
 *	* контекст заполняется ссылками на родителя, контекст, "родственные"
 *	объекты, текущий объект
 *	* заполняются свойства объекта
 *	* заполняется содержимое объекта при помощи функции setContents()
 *	* создаются локальные классы
 *	* создаются дочерние объекты и добавляются в контекст
 *	* заполняются дочерние объекты (на момент заполнения все дочерние
 *	объекты созданы и доступны через контекст родителя)
 *	* происходит подключение сигналов/слотов при помощи функции
 *	makeConnection()
 *	* происходит привязка свойств при помощи функции makeBinding()
 * Таким образом гарантируется, что при создании объекта родительский объект
 * уже создан, а при заполнении объекта заполнены все (статические) свойства
 * родительского объекта и его контекст.
 *
 * Для подключения сигналов/слотов используется механизм, предоставленный
 * функцией QObject::connect. При подключении необходимо, чтобы в контексте
 * присутствовали и отправитель, и получатель, а также у них должны
 * существовать указанные сигнал и слот.
 *
 * TODO: В настоящее время поддерживаются только сигналы/слоты без параметров.
 *
 * Привязка свойств работает аналогично привязке в QML - при изменении свойства
 * должен генерироваться сигнал, по которому обновляются привязанные свойства.
 * При этом свойства могут еще не существовать (динамические свойства).
 *
 * Привязка осуществляется функцией bindProperty() объекта-получателя и
 * вспомогательным классом PropertyListener. Если свойство-источник является
 * статическим и имеет сигнал, оповещающий о его изменении, этот сигнал
 * привязывается к слоту объекта PropertyListener, в котором устанавливается
 * значение свойства-приемника. Если же сигнал оповещения недоступен, свойство
 * добавляется в список привязки, а объект-получатель добавляется в фильтры
 * событий объекта-источника функцией QObject::installEventFilter. Фильтр
 * событий анализирует событие изменения свойства и явно вызывает слот объекта
 * PropertyListener, если свойство присутствует в списке привязки. При создании
 * привязки отправитель и получатель должны существовать.
 *
 * При создании привязки предыдущая привязка совйства-получателя удаляется.
 */
class GSObject : public QObject {
	Q_OBJECT
public:
	/**
	 * @brief Конструктор класса GSObject.
	 * @param parent родительский объект
	 */
	GSObject(GSObject* parent = NULL);

	virtual void initProperties();

	/**
	 * @brief Функция заполнения объекта.
	 * Заполняет содержимое объекта на основе описания из исходного файла.
	 * Функция производит следующие действия:
	 *	* создает или наследует контекст
	 *	* заполняет контекст ссылками на видимые объекты
	 *	* заполняет свойства объекта
	 *	* заполняет содержимое объекта при помощи функции setContents()
	 *	* создает локальные классы
	 *	* создает и добавляет в контекст дочерние объекты
	 *	* заполняет дочерние объекты
	 *	* выполняет подключение сигналов/слотов
	 *	* выполняет привязку свойств
	 * @param item описание объекта
	 * @return признак отсутствия ошибок
	 */
	virtual bool loadSource(SourceItem* item);

	/**
	 * @brief Получение объекта из контекста.
	 * Возвращает объект из контекста с заданным именем. Имя может быть
	 * одним из зарезервированных:
	 *	* **this** - текущий объект
	 *	* **parent** - родительский объект
	 *	* **context** или пустое имя - объект контекста
	 * TODO: Сложные имена, содержащие точку, в настоящее время не
	 * поддерживаются.
	 * @param name имя объекта
	 * @return указатель на объект или NULL, если объект не существует
	 */
	GSObject *localObject(const QString &name) const;

	/**
	 * @brief Добавление/изменение объекта в контексте.
	 * @param name имя объекта
	 * @param obj объект
	 */
	void setLocalObject(const QString &name, GSObject* obj);

	/**
	 * @brief Список имен всех видимых объектов.
	 * Возвращает список имен всех видимых объектом, включая сам объект,
	 * его дочерние объекты, контекст, родительский объект и его дочерние
	 * объекты. Включает "дубликаты" объктов - например, **parent** и имя
	 * родительского объекта, ссылающиеся на один и тот же объект.
	 * @return список имен видимых объектов
	 */
	QStringList localObjects() const;

	/**
	 * @brief Список имен всех дочерних объектов.
	 * @return список имен дочерних объектов
	 */
	QStringList childrenObjects() const;

	/**
	 * @brief Свойство объекта.
	 * Возвращает значение свойства GS-объекта.
	 * @param name имя свойства
	 * @return значение свойства
	 */
	QVariant gsProperty(const QString& name) const;

	/**
	 * @brief Признак наличия свойства.
	 * Возвращает true, если свойство существует (либо статическое, либо
	 * динамическое).
	 * @param name имя свойства
	 * @return true, если свойство существует
	 */
	bool hasGSProperty(const QString& name) const;

	/**
	 * @brief Задание или изменение значения свойства.
	 * Изменяет значение указанного свойства. Если свойство не существует,
	 * будет добавлено динамическое свойство с заданным именем.
	 * @param name имя свойства
	 * @param value новое значение свойства
	 */
	virtual void setGSProperty(const QString& name, const QVariant &value);

	/**
	 * @brief Список имен всех свойств объекта.
	 * Возвращает список имен всех свойств объекта, статических и
	 * динамических.
	 * @return список имен свойств объекта
	 */
	QStringList gsProperties() const;

	/**
	 * @brief Объект контекста.
	 * Возвращает объект контекста для данного объекта. При создании
	 * объекта контекст наследуется от родителя, либо создается при
	 * помощи функции makeContext(), если родитель отсутствует.
	 * @return объект контекста
	 */
	GSContext *contextObject();

	/**
	 * @brief Объект QML-контекста.
	 * Возвращает объект QML-контекста, создавая его, если он не
	 * существует. Если у объекта есть родитель и у него есть QML-контекст,
	 * то QML-контекст объекта создается на основе QML-контекста родителя,
	 * иначе QML-контекст создается при помощи функции
	 * makeRootQmlContext().
	 * @return QML-контекст
	 */
	QQmlContext *qmlContext();

	/**
	 * @brief Центральный объект.
	 * Возвращает объект, свойства, сигналы и слоты которого могут
	 * использоваться другими объектами через данный интерфейс. По
	 * умолчанию центральным объектом является сам GS-объект, но в
	 * некоторых случаях (например, для QML-объекта) это может быть не так.
	 * @return центральный объект
	 */
	virtual const QObject *object() const;
	/**
	 * @brief Центральный объект.
	 * Возвращает объект, свойства, сигналы и слоты которого могут
	 * использоваться другими объектами через данный интерфейс. По
	 * умолчанию центральным объектом является сам GS-объект, но в
	 * некоторых случаях (например, для QML-объекта) это может быть не так.
	 * @return центральный объект
	 */
	virtual QObject *object();

	/**
	 * @brief Родительский объект.
	 * Возвращает родительский GS-объект.
	 * @return родительский объект
	 */
	GSObject *gsParent() const;

	/**
	 * @brief Привязка свойства.
	 * Привязывает свойство данного объекта к свойству другого (или этого
	 * же) объекта.
	 *
	 * Привязка осуществляется при помощи вспомогательного класса
	 * PropertyListener. Если свойство-источник является статическим и
	 * имеет сигнал, оповещающий о его изменении, этот сигнал привязывается
	 * к слоту объекта PropertyListener, в котором устанавливается значение
	 * свойства-приемника. Если же сигнал оповещения недоступен, свойство
	 * добавляется в список привязки, а объект-получатель добавляется в
	 * фильтры событий объекта-источника функцией
	 * QObject::installEventFilter. Фильтр событий анализирует событие
	 * изменения свойства и явно вызывает слот объекта PropertyListener,
	 * если свойство присутствует в списке привязки.
	 *
	 * При создании привязки отправитель и получатель должны существовать,
	 * свойства источник и получатель могут не существовать.
	 *
	 * @param obj объект-получатель
	 * @param src свойство-источник
	 * @param dst свойство-получатель
	 * @return созданный объект PropertyListener
	 */
	virtual PropertyListener *bindProperty(GSObject* obj, QString src, QString dst);
	/**
	 * @brief Удаление привязки свойства.
	 * Удаляет привязку заданного свойства данного объекта. Значение
	 * свойства сохраняется.
	 * @param dst свойство-получатель
	 */
	void removeBinding(QString dst);

	/**
	 * @brief Фильтр событий.
	 * Используется для отслеживания событий изменения динамический свойств
	 * объекта-источника, к которым привязаны свойства данного объекта.
	 * @param obj объект-источник
	 * @param e событие
	 * @return признак фильтрации
	 */
	virtual bool eventFilter(QObject *obj, QEvent *e);

	/**
	 * @brief Имя объекта.
	 * @return имя объекта
	 */
	QString name() const;
	/**
	 * @brief Задание имени объекта.
	 * Функция не проверяет существование объекта с заданным именем в
	 * контексте и не обновляет контексты. Функцию следует использовать до
	 * заполнения контекста самого объекта, а также родительского и
	 * дочерних объектов.
	 * @param name новое имя объекта
	 */
	void setName(const QString &name);

	/**
	 * @brief Преобразование вектора в скаляр.
	 * Если в качестве аргумента передается вариант векторного типа
	 * (QVariant::List или QVariant::StringList), функция возвращает первый
	 * элемент массива.
	 * @param var аргумент
	 * @return первый элемент массива
	 */
	static QVariant gsToScalar(const QVariant& var);

signals:
	/**
	 * @brief Сигнал об изменении значения свойства.
	 * Сигнал генерируется при изменении значения свойства функцией
	 * setGSProperty(). При этом не проверяется, действительно ли значение
	 * свойства поменялось. Также сигнал не будет генерироваться при
	 * изменении значения свойства другими способами (непосредственно через
	 * центральный объект).
	 * @param name имя свойства
	 */
	void gsPropertyChanged(const QString& name, const QVariant& value);

protected:
	/**
	 * @brief Установка соединения сигнал-слот.
	 * При подключении необходимо, чтобы в контексте присутствовали и
	 * отправитель, и получатель, а также у них должны существовать
	 * указанные сигнал и слот.
	 *
	 * TODO: В настоящее время поддерживаются только сигналы/слоты без
	 * параметров.
	 * @param connection описание соединения
	 * @return признак успеха
	 */
	bool makeConnection(SourceLink connection);
	/**
	 * @brief Создание привязки свойства.
	 * @param binding описание привязки
	 * @return признак успеха
	 */
	bool makeBinding(SourceLink binding);
	/**
	 * @brief Установка содержимого объекта.
	 * Передает в объект содержимое соответствующего узла в исходном файле.
	 * @param contents значение содержимого
	 * @return признак успеха
	 */
	virtual bool setContents(const QString& contents);

	/**
	 * @brief Сигнатура сигнала.
	 * Возвращает строковую сигнатуру указанного сигнала для передачи в
	 * функцию QObject::connect. Исходный сигнал может быть указан как
	 * сигнатурой (signalName(int)), так и именем (signalName). В последнем
	 * случае считается, что сигнал без параметров.
	 *
	 * Функция использует Qt-specific сведения о работе макроса SIGNAL и
	 * может не работать в некоторых версиях Qt. Протестировано в Qt 5.5.
	 * @param signal имя сигнала
	 * @return сигнатура сигнала
	 */
	static QString signalStr(const QString &signal);
	/**
	 * @brief Сигнатура слота.
	 * Возвращает строковую сигнатуру указанного слота для передачи в
	 * функцию QObject::connect. Исходный слот может быть указан как
	 * сигнатурой (slotName(int)), так и именем (slotName). В последнем
	 * случае считается, что слот без параметров.
	 *
	 * Функция использует Qt-specific сведения о работе макроса SLOT и
	 * может не работать в некоторых версиях Qt. Протестировано в Qt 5.5.
	 * @param slot имя слота
	 * @return сигнатура слота
	 */
	static QString slotStr(const QString &slot);

	/**
	 * @brief Создание корневого QML-контекста.
	 * Вызывается при обращении к QML-контексту, если родительский элемент
	 * не существует или не содержит (и не создает) QML-контекст. Созданный
	 * QML-контекст сохраняется и используется при всех дальнейших
	 * обращениях. Реализация по умолчанию возвращает NULL.
	 * @return созданный QML-контекст
	 */
	virtual QQmlContext *makeRootQmlContext();
	/**
	 * @brief Создание контекста.
	 * Функция создает контекст для текущего объекта на основе заданного
	 * контекста. Реализация по умолчанию возвращает заданный контекст -
	 * таким образом, контекст дочернего класса наследуется у родителя.
	 * Объекты верхнего уровня (главное окно, диалоги) должны создавать
	 * собственный контекст.
	 * @param parent родительский контекст
	 * @return контекст
	 */
	virtual GSContext *makeContext(GSContext *parent = NULL);

protected slots:
	void processPropertyChange(const QString &name, const QVariant &value);

private:
	GSObject* mParent;
	QQmlContext* mQmlContext;
	GSContext* mContext;
	QString mName;
	QMap<QString, GSObject*> mLocalContext;
	QStringList mSiblings;
	QStringList mChildren;

	QMap<QObject*, QMap<QString, QStringList> > mBinding;
	QMap<QString, PropertyListener*> mListeners;
	QMap<QString, OwnNotifier*> mOwnNotifiers;
};


/**
 * @brief Класс-строитель объекта.
 *
 * Класс конструирует объекты определенного типа на основе заданного описания.
 * Для создания объекта предназначена функция makeObject().
 *
 * Класс поддерживает возможность создания на основе конструкции class языка
 * Squill производных классов, строителей для них, а также производных описаний
 * для объектов производных классов. Шаблон, заданный при помощи конструкции
 * **class**, сохраняется в классе-строителе. При создании объекта производного
 * класса описание класса дополняется данными из шаблона, отсутствующими в
 * описании объекта. Семантика данных не анализируется, данные подставляются в
 * объект SourceItem. Для создания строителя производного класса используется
 * функция makeEnhancedBuilder(). Для создания описания объекта производного
 * класса на основе шаблона и собственного описания объекта из файла
 * используется функция makeSource().
 *
 * Последовательность создания производного класса выглядит следующим образом:
 *	1. Создать строителя для производного класса при помощи функции
 *	makeEnhancedBuilder() строителя базового класса и описания класса.
 *	2. Создать новый объект при помощи makeObject().
 *	3. Создать производное описание объекта на основе описания из файла при
 *	помощи makeSource().
 *	4. Заполнить объект при помощи GSObject::loadSource и созданного
 *	описания.
 */
class GSObjectBuilder {
public:
	GSObjectBuilder();
	virtual ~GSObjectBuilder();

	/**
	 * @brief Создание нового GS-объекта.
	 * Создает новый GS-объект класса, соответствующего данному строителю.
	 * @param parent родительский объект
	 * @return новый объект
	 */
	virtual GSObject* makeObject(GSObject *parent) const = 0;

	/**
	 * @brief Создание расширенного описания объекта.
	 * Создает расширенное описание объекта на основе заданного описания и
	 * сохраненного в строителе шаблона описания.
	 * @param item описание объекта
	 * @return дополненное описание объекта
	 */
	SourceItem* makeSource(SourceItem* item) const;

	/**
	 * @brief Создание строителя производного класса.
	 * Создает строителя класса, производного от данного, на основе
	 * заданного описания класса.
	 * @param item описание класса
	 * @return строитель производного класса
	 */
	GSObjectBuilder* makeEnhancedBuilder(SourceItem* item);

	/**
	 * @brief Имя класса, соответствующего строителю.
	 * @return имя класса
	 */
	QString name() const;
	/**
	 * @brief Задание имени класса, соответствующего строителю.
	 * @param name новое имя класса
	 */
	void setName(const QString &name);

	/**
	 * @brief Создание копии строителя.
	 * На основе копии строителя создается строитель производного класса.
	 * Строители базового и производного класса отличаются только шаблоном.
	 * @return копия строителя
	 */
	virtual GSObjectBuilder* clone() const = 0;

	/**
	 * @brief Шаблон объекта класса.
	 * Возвращает шаблон описания объекта класса. При создании объекта
	 * производного класса данные из шаблона добавляются в описание
	 * объекта, если еще там не присутствуют. Информация из описания
	 * объекта более приоритетна, чем из шаблона. Например, если одно и то
	 * же свойство по-разному описано в шаблоне и описании объекта, то в
	 * итоговом объекте свойство будет соответствовать описанию объекта.
	 *
	 * По умолчанию шаблон пуст.
	 * @return шаблон объекта класса
	 */
	SourceItem *enhancement() const;
	/**
	 * @brief Задание шаблона объекта класса.
	 * @param enhancement новый шаблон
	 */
	void setEnhancement(SourceItem *enhancement);

private:
	SourceItem* mEnhancement;
	QString mName;
};

/**
 * @brief Фабрика объектов.
 *
 * Класс описывает синглтон, при помощи которого можно создавать новые объекты
 * известных фабрике классов.
 *
 * Перед началом работы необходимо добавить в фабрику строителей объектов для
 * поддерживаемых классов. Можно добавлять строителей как явно (для базовых
 * классов), так и при помощи разбора описания класса из файла (для производных
 * классов). В последнем случае требуется, чтобы строитель базового класса уже
 * присутствовал в фабрике.
 *
 * Фабрика поддерживает стек областей видимости определений классов. Если в
 * локальной области видимости (определение объекта) задается новое определение
 * для уже существующего класса, оно перекрывает существующее до тех пор, пока
 * не будет вызвана функция unregisterBuilder(), после чего активным станет
 * предыдущее определение класса. Таким образом, при входе в новую область
 * видимости следует зарегистрировать все локальные определения класса, а при
 * выходе удалить их из фабрики.
 *
 * Аналогично классу GSObjectBuilder, фабрика позволяет создавать как новые
 * объекты при помощи функции makeObject(), так и определения объектов для
 * передачи в GSObject::loadSource при помощи функции makeSource.
 */
class GSObjectFactory : private QMap<QString, QStack<GSObjectBuilder*> > {
public:
	/**
	 * @brief Создание объекта.
	 * Создает новый объект по заданному определению объекта. Строитель
	 * класса данного объекта должен присутствовать в фабрике, иначе
	 * функция вернет NULL.
	 * @param item определение объекта
	 * @param parent родительский объект
	 * @return созданный объект
	 */
	GSObject* makeObject(SourceItem* item, GSObject *parent);
	/**
	 * @brief Создание описания нового объекта.
	 * Создает описание нового объекта на основе переданного описания из
	 * файла и шаблона, заданного для соответствующего строителя.
	 * @param item описание объекта из файла
	 * @return дополненное описание объекта
	 */
	SourceItem* makeSource(SourceItem* item);
	/**
	 * @brief Регистрация строителя.
	 * Регистрирует явно заданного строителя.
	 * @param builder строитель
	 */
	void registerBuilder(GSObjectBuilder* builder);
	/**
	 * @brief Регистрация строителя.
	 * Регистрирует строителя, заданного при помощи описания класса.
	 * Строитель базового класса должен присутствовать в фабрике.
	 * Предыдущий строитель, заданный для соответствующего имени класса,
	 * будет скрыт, пока не будет вызвана функция unregisterBuilder().
	 * @param item описание класса
	 */
	void registerBuilder(SourceItem* item);
	/**
	 * @brief Удаление регистрации строителя.
	 * Удаляет регистрацию последнего заданного строителя для заданного
	 * имени класса. Если ранее для этого имени класса был задан еще один
	 * строитель, он становится видимым.
	 * @param className имя класса
	 */
	void unregisterBuilder(QString className);

	/**
	 * @brief Указатель на фабрику.
	 * Статическая функция, возвращающая указатель на фабрику. Фабрика
	 * создается при первом обращении.
	 * @return указатель на фабрику
	 */
	static GSObjectFactory *factory();
private:
	GSObjectFactory() {}

	static GSObjectFactory* mFactory;
};

/**
 * Макрос для объявления класса-строителя.
 * Макрос позволяет определить класс-строитель для заданного GS-класса. Имя
 * класса-строителя будет составлено из имени GS-класса с постфиксом Builder.
 * @param className имя GS-класса в терминах C++
 * @param strName имя GS-класса в терминах Squill
 */
#define DEFINE_GSCLASS(className, strName)				\
class className;							\
class className##Builder : public GSObjectBuilder {			\
public:									\
	className##Builder() {setName(strName);}			\
	virtual GSObject *makeObject(GSObject *parent) const		\
		{return new className(parent);}				\
protected:								\
	virtual GSObjectBuilder *clone() const {			\
		GSObjectBuilder *res = new className##Builder();	\
		res->setEnhancement(new SourceItem(enhancement()));	\
		return res;						\
	}								\
};									\

#endif // GSOBJECT_H
