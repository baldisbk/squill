#ifndef SOURCEPARSER_H
#define SOURCEPARSER_H

#include <QXmlStreamReader>
#include <QMap>

// node reswords
#define CLASS_RESWORD "class"
#define SCRIPT_RESWORD "script"
#define CONNECT_RESWORD "connect"
#define BINDING_RESWORD "bind"
#define DATABASE_RESWORD "database"

// property reswords
#define NAME_RESWORD "name"
#define SOURCE_RESWORD "src"
#define DEST_RESWORD "dst"
#define SIGNAL_RESWORD "signal"
#define SLOT_RESWORD "slot"
#define SRCPROP_RESWORD "srcprop"
#define DSTPROP_RESWORD "dstprop"

// value reswords
#define PARENT_RESWORD "parent"
#define THIS_RESWORD "this"
#define CONTEXT_RESWORD "context"

#define VALUE_SYMBOL '#'
#define LINK_SYMBOL '@'

/**
 * @brief Типы значения свойства.
 */
enum AttrType {
	attrValue,	//!< свойству присвоено значение
	attrBind,	//!< свойство привязано к другому свойству
	attrScript	//!< свойство привязано к встроенному скрипту
};

/**
 * @brief Структура описания свойства.
 */
struct SourceAttr {
	QString name;	//!< имя свойства
	QString value;	//!< значение или привязка
	AttrType type;	//!< тип значения
};

/**
 * @brief Структура описания привязки или соединения.
 */
struct SourceLink {
	QString src;		//!< имя объекта-источника
	QString srcprop;	//!< имя свойства-источника или сигнала
	QString dst;		//!< имя объекта-получателя
	QString dstprop;	//!< имя свойства-получателя или слота
};

/**
 * @brief Структура описания объекта.
 * Структура обладает функциональностью чтения содержимого объекта из объекта
 * чтения XML и разбора этого содержимого в соответствии с правилами языка
 * Squill.
 *
 * В структуре хранятся:
 *	* имя, тип и содержимое (текст) объекта
 *	* значения свойств
 *	* информация о соединениях сигнал-слот, объявленных в контексте данного
 * объекта
 *	* информация о привязке свойств, объявленных в контексте данного
 * объекта (привязка может быть объявлена для любого объекта, видимого данному
 * объекту)
 *	* список дочерних структур
 *
 * При разборе тип объекта определяется типом xml-узла, имя объекта - значением
 * специального свойства **name**. Значения остальных свойств заносятся в
 * список свойств. Поддерживаются три типа значения свойства: явное значение,
 * привязка и скрипт. Для различия типов используются специальные символы в
 * качестве префикса значения.
 *
 * Явное значение свойства является типом значения по умолчанию: если префикс
 * не указан, значение является явным. Также явное значение задается при помощи
 * префикса *"#"*. TODO: умолчание должно определяться классом.
 *
 * Значение с типом привязки и скрипта задается при помощи префикса *"@"*. Если
 * значение представляет собой последовательность идентификаторов, разделенных
 * точками, оно трактуется как привязка, иначе - как скрипт. Привязка
 * добавляется в список привязок объекта и не добавляется в список свойств.
 *
 * Привязка интерпретируется следующим образом: последний идентификатор в
 * списке является именем свойства-источника, остальные составляют имя
 * объекта-источника. Если имя объекта не задано, то привязка вида *"property"*
 * интерпретируется как привязка к объекту **this**, а привязка *".property"*
 * (начинающаяся с точки) - как привязка к объекту **context**.
 *
 * Дочерние узлы типов **bind** и **connect** не порождают дочерних объектов, а
 * интерпретируются как описания привязки свойств и соединения сигнал-слот,
 * соответственно. Для узлов этих типов анализируются значения следующих
 * атрибутов:
 *	* **src** - объект-источник (для привязки и соединения)
 *	* **dst** - объект-получатель (для привязки и соединения)
 *	* **signal** - сигнал объекта-источника (только для соединения)
 *	* **slot** - слот объекта-получателя (только для соединения)
 *	* **srcprop** - свойство-источник (только для привязки)
 *	* **dstprop** - свойство-получатель (только для привязки)
 * Если имя свойства, сигнала или слота не задано, то имя соответствующего
 * объекта разбирается аналогично указанному выше правилу для привязки свойств:
 * последний идентификатор определяет имя свойства, сигнала или слота,
 * остальные - имя объекта. Если не задан атрибут, содержащий имя объекта, но
 * задан атрибут, содержащий имя свойства, сигнала или слота, то в качестве
 * имени соответствующего объекта берется **this**.
 *
 * Чтение объекта происходит при помощи функции read(). Функция читает
 * содержимое текущего узла в объекте QXmlStreamReader, включая все дочерние
 * узлы. Таким образом, функция работает рекурсивно, и результатом разбора
 * структуры XML на верхнем уровне является единственный экземпляр структуры
 * SourceItem, хранящий информацию о корневом объекте вместе со всеми дочерними
 * элементами.
 *
 * Структура не выполняет функции семантического анализатора - существование
 * свойств, сигналов, слотов, строителей классов и т.п. не проверяется.
 */
struct SourceItem {
	QString type;		//!< тип объекта
	QString name;		//!< имя объекта
	QString contents;	//!< содержимое (текст) объекта
	QMap<QString, SourceAttr> attributes;	//!< свойства объекта
	QMap<QString, SourceItem*> children;	//!< дочерние объекты
	QList<SourceLink> bindings;	//!< описания привязок
	QList<SourceLink> connects;	//!< описания соединений сигнал-слот

	/**
	 * @brief Функция чтения описания из XML.
	 * Функция читает содержимое текущего узла в объекте QXmlStreamReader,
	 * включая все дочерние узлы.
	 * @param reader объект-читатель XML
	 */
	void read(QXmlStreamReader& reader);

	/**
	 * @brief Конструктор.
	 * Конструктор по умолчанию.
	 */
	SourceItem() {}

	/**
	 * @brief Конструктор
	 * Конструктор, копирующий содержимое другого описания
	 * @param other описание-источник
	 */
	SourceItem(SourceItem* other) {
		*this = *other;
		children.clear();
		foreach(SourceItem* child, other->children)
			children[child->name] = new SourceItem(child);
	}
	/**
	 * @brief Деструктор.
	 * Деструктор удаляет и все дочерние объекты, поэтому для удаления
	 * описания проекта достаточно удалить корневой элемент.
	 */
	~SourceItem() {
		foreach(SourceItem* child, children)
			delete child;
	}

private:
	/**
	 * @brief Разбор объекта как связи.
	 * Данный объект интерпетируется как связь - привязка или соединение
	 * сигнал-слот. Происходит чтение и разбор соответствующих атрибутов:
	 * имена объекта-источника и объекта приемника определяются ключевыми
	 * словами **src** и **dest** соответственно, имена свойств, сигналов
	 * и слотов определяются ключевыми словами, переданными в качестве
	 * параметров.
	 * @param sprRW ключевое слово свойства-источника или сигнала
	 * @param dprRW ключевое слово свойства-получателя или слота
	 * @return описание связи
	 */
	SourceLink readLink(QString sprRW, QString dprRW) const;
	/**
	 * @brief Разбор значений атрибутов связи.
	 * Функция создает описание связи на основе переданных значений
	 * атрибутов - имен объектов и имен свойств для источника и получателя.
	 * Атрибуты имен свойств представляют имена свойства-источника и
	 * свойства-получателя для привязки и сигнала и слота для соединения.
	 *
	 * Атрибуты источника и получателя могут представлять собой
	 * последовательность идентификаторов, разделенных точкой. В этом
	 * случае последний идентификатор в списке является именем свойства,
	 * остальные составляют имя объекта-источника. Если имя объекта не
	 * задано, то привязка вида *"property"* интерпретируется как привязка
	 * к объекту **this**, а привязка *".property"* (начинающаяся с
	 * точки) - как привязка к объекту **context**.
	 * @param src имя объекта-источника
	 * @param srcprop имя свойства-источника или сигнала
	 * @param dst имя объекта-получателя
	 * @param dstprop имя свойства-получателя или слота
	 * @return описание связи
	 */
	static SourceLink readLink(
		QString src, QString srcprop, QString dst, QString dstprop);
	/**
	 * @brief Разбор описания привязки из атрибута.
	 * Функция создает описание привязки свойства на основе описания
	 * свойства. Функция предполагает, что в описании свойства задана
	 * привязка и в значении привязки уже нет префикса.
	 * @param attr описание атрибута
	 * @return описание привязки
	 */
	static SourceLink readLink(SourceAttr attr);
	/**
	 * @brief Разбор описания атрибута.
	 * Функция создает описание атрибута на основе имени и значения из xml.
	 * Определяется тип атрибута - значение, привязка или скрипт.
	 * @param n
	 * @param val
	 * @return
	 */
	static SourceAttr readAttr(QString n, QString val);
};

#endif // SOURCEPARSER_H
